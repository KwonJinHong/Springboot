# [JPA] 기초 지식 정리

## 1. JPA란?
- Java Persistence API의 약자로 ORM 기술 표준이다.
- 대표적인 구현체로 Hibernate가 있다.

## 2. ORM?
- Object-Realational Mapping
- 객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- 이를 ORM 프레임워크가 중간에서 매핑한다.
- 대중적인 언어의 대부분은 ORM 기술이 존재한다.

## 3. 객체지향과 데이터
객체는 보통 데이터와 관련된 연산의 집합을 이르는 말이다. 데이터의 묶음을 보통 자료구조라고 한다. 객체의 큰 특징으로는 아래의 네가지가 있다
- 캡슐화
- 추상화
- 다형성
- 상속

관계형 데이터베이스에서, 데이터는 연산을 가지지 않는다. 상속이나 캡슐화 등이 될 리는 더더욱 만무하다. 대신, 데이터는 외래 키를 사용한 양방향 관계 를 가질 수 있는데, 이러한 양방향 관계는 객체에서 참조를 통해 유사하게 구현할 수 있지만, 완전히 일치하게 구현하기 위해서는 많은 개발 비용이 든다.

결론적으로 객체와 관계형 데이터베이스를 예쁘게 잘 붙일수 있게 도와주는 프레임워크가 "ORM"이다.

## 4. JPA를 사용해야하는 이유?
- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성, 유지보수에서 강점 (JPA를 사용하여 SQL 문장 java 코드로 대체가능)
- 패러다임의 불일치 해결
- JPA는 SQL 방언을 지원하여 특정 데이터베이스에 종속되지 않는다.

## 5. Entity
### 5-1. 개념과 선언
엔티티 클래스는 테이블과 매핑되는 클래스이다. 

`@Entity` , `@Table` , `@Colum` 등의 애노테이션을 사용하여 적절히 엔티티 클래스를 구성하고, 완성된 엔티티 클래스는 명세를 기반으로 테이블과 매핑된다.

```java
@Entity
@Table(name ="member")
public class Member {

    @Id
    @GeneratedValue (strategy = GenerationType.AUTO) // ID에 시퀀스를 부여해 자동 생성
    @Column (name = "MEMBER_ID")
    private Long id;
    private String name;
    private String city;
    private String street;
    private String zipcode;
```
- Member 클래스는 DB의 member 테이블에 매핑된다.

## 5-2. Entity의 상태(생명주기)
엔티티 클래스를 바탕으로 생성된 엔티티는 생성부터 제거되기까지 4가지의 상태를 가질 수 있다.

- New / 비영속
- Managed /영속
- Detached / 준영속
- Removed / 삭제

영속성 상태의 엔티티는 아래의 특징을 가진다.
- 1차 캐시
    - 엔티티는 엔티티 메니저가 가지는 내부 캐시에 저장된다. 데이터베이스에서 읽은 이력이 있는 데이터는 이 1차 캐시에 저장되어 재사용된다.
    
- 동일성
    - 같은 식별값을 가지는 모든 엔티티는 동일히다. 참조하는 주소가 같다는 의미.

- 쓰기 지연과 변경 감지
    - 트랜잭션 종료 시점에서, 엔티티 매니저는 엔티티의 변경사항을 감지하여 데이터베이스에 업데이트한다.
    - 특정 옵션을 사용시, 변경된 필드에 대해서만 업데이트를 수행하는 쿼리를 생성할 수 있다.

- 지연 로딩
    - lazy 옵션을 사용하여 엔티티와 관련 있는 데이터의 로드를 해당 데이터가 필요한 시점까지 지연시킬 수 있다.

## 6. 트랙잭션
### 6-1. 트랜잭션?
트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

### 6-2. 트랜잭션의 특징
- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

### 6-3. 트랜잭션의 성질 
**Atomicity(원자성)**
- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

 

**Consistency(일관성)**
- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

 

**Isolation(독립성,격리성)**
- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

- 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

 

**Durablility(영속성,지속성)**
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

### 6-4. 트랜잭션 연산 및 상태 
**Commit연산**
- Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

 

**Rollback연산**
- Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.

- Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.
